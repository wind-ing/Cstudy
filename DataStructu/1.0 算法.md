# 算法

<!-- TOC -->

- [算法](#算法)
  - [基本概念](#基本概念)
  - [算法的时间复杂度](#算法的时间复杂度)
  - [算法的空间复杂度](#算法的空间复杂度)
  - [错题本补充](#错题本补充)

<!-- /TOC -->

## 基本概念

- 算法：是对特定问题求解步骤的一种描述，是指令的有限序列，其中的每条指令表示一个或多个操作

> 程序 = 数据结构 + 算法

- 算法的特性

> 1. 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都在有穷时间内完成。（算法必须是有穷的，而程序可以是无穷的）
> 2. 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出
> 3. 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。（输入：一个算法有零个或多个输入；输出：一个算法有一个或多个输出）

- 好算法的特质

> 1. 正确性
> 2. 可读性
> 3. 健壮性（输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果)
> 4. 高效率（时间复杂度低）与低存储量需求（空间复杂度低）

## 算法的时间复杂度

- 与算法本身无关的外界相关因素

> 让算法先运行，事后统计运行时间  
> 机器性能  
> 编程语言（越高级的语言执行效率越低）  
> 编译程序产生的机器指令质量  
> 有些算法不能事后统计

- 算法时间复杂度

> 事前预估算法时间开销$T(n)$与问题规模$n$的关系（$T$表示$“time”$)  
> 一个算法的时间表达式只保留阶数高的部分即可

- 如何计算
>
> 1. 找到一个基本操作（最深层循环）
> 2. 分析该基本操作的执行次数x与问题规模n的关系x=f(n)  
> 3. x的数量级O(x)就是算法时间复杂度T(n)

- 简化计算

> $T_1(n) = O(n)$  
> $T_2(n) = O(n^2)$  
> $T_3(n) = O(n^3)$  
> $T(n) = T_1(n) + T_2(n) = O(f(n))+ O(g(n)) = O(max(f(n),g(n)))$  
> $T(n) = T_1(n) \times T_2(n) = O(f(n)\times g(n)) = O(f(n)\times g(n))$

- 时间复杂度的排序

> $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$  
> (常对幂指阶)

- 三种复杂度

> 最坏时间复杂度  
> 平均时间复杂度  
> 最好时间复杂度

## 算法的空间复杂度

- 相关因素
  
> 程序代码：大小固定，与问题规模无关  
> 数据：参数等  
> 函数递归调用带来的内存开销

- 如何计算

> 1. 普通程序  
> 找到所占空间大小与问题规模相关的变量  
> 分析所占空间x与问题规模n的关系x=f(n)  
> x的数量级O(x)就是算法空间复杂度S(n)
> 2. 递归程序  
> 找到递归调用的深度x与问题规模n的关系x=f(n)  
> x的数量级O(x)就是算法空间复杂度S(n)  

- 简化计算

> S(n)($S$表示$“Space”$)

## 错题本补充

- 一个算法应该是`问题求解步骤的描述`
